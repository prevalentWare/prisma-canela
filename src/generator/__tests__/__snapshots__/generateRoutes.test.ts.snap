// Vitest Snapshot v1, https://vitest.dev/guide/snapshot.html

exports[`generateRoutesFileContent > should generate correct refactored route file content for a User model 1`] = `
"import { OpenAPIHono, createRoute, z } from '@hono/zod-openapi';
import { validator } from 'hono/validator';
import { UserSchema, createUserSchema, updateUserSchema } from './schema';
import { Role } from '@prisma/client';
import * as controller from './controller';



// --- Route Definitions ---
// GET /users
const listUserRoute = createRoute({
  method: 'get',
  path: '/',
  tags: ['User'],
  summary: 'List all users',
  responses: {
    200: {
      description: 'Returns a list of users',
      content: {
        'application/json': {
          schema: z.array(UserSchema),
        },
      },
    },
    // TODO: Define 500 error response
  },
});

// Define ID-based routes only if idField exists

// GET /users/{id}
const getUserByIdRoute = createRoute({
  method: 'get',
  path: '/{id}',
  tags: ['User'],
  summary: 'Get a user by ID',
  request: {
    params: z.object({
      id: z.string().pipe(z.coerce.number().int({ message: "Invalid ID format"})),
    }),
  },
  responses: {
    200: {
      description: 'Returns the user',
      content: {
        'application/json': {
          schema: UserSchema,
        },
      },
    },
    404: {
      description: 'User not found',
      // TODO: Define standard error schema
    },
    // TODO: Define 400, 500 error responses
  },
});

// PATCH /users/{id}
const updateUserRoute = createRoute({
  method: 'patch',
  path: '/{id}',
  tags: ['User'],
  summary: 'Update a user by ID',
  request: {
    params: z.object({
      id: z.string().pipe(z.coerce.number().int({ message: "Invalid ID format"})),
    }),
    body: {
      content: {
        'application/json': {
          schema: updateUserSchema,
        },
      },
    },
  },
  responses: {
    200: {
      description: 'Returns the updated user',
      content: {
        'application/json': {
          schema: UserSchema,
        },
      },
    },
    400: {
      description: 'Invalid input',
      // TODO: Define standard error schema
    },
    404: {
      description: 'User not found',
      // TODO: Define standard error schema
    },
     // TODO: Define 500 error response
  },
});

// DELETE /users/{id}
const deleteUserRoute = createRoute({
  method: 'delete',
  path: '/{id}',
  tags: ['User'],
  summary: 'Delete a user by ID',
  request: {
    params: z.object({
      id: z.string().pipe(z.coerce.number().int({ message: "Invalid ID format"})),
    }),
  },
  responses: {
    200: { // Consider 204 No Content if not returning the object
      description: 'User deleted successfully',
      content: {
        'application/json': {
            // Optional: Return the deleted object's ID or a success message
            schema: z.object({ id: z.number() }) // Use actual ID field name
        },
      },
    },
    404: {
      description: 'User not found',
      // TODO: Define standard error schema
    },
    // TODO: Define 400, 500 error responses
  },
});
 // End of conditional ID routes

// POST /users - Always defined
const createUserRoute = createRoute({
  method: 'post',
  path: '/',
  tags: ['User'],
  summary: 'Create a new user',
  request: {
    body: {
      content: {
        'application/json': {
          schema: createUserSchema,
        },
      },
    },
  },
  responses: {
    201: {
      description: 'Returns the created user',
      content: {
        'application/json': {
          schema: UserSchema,
        },
      },
    },
    400: {
      description: 'Invalid input',
      // TODO: Define standard error schema
    },
    // TODO: Define 500 error response
  },
});




// --- Hono App Setup ---
// Using standard Hono methods for clearer middleware application
const userRoutes = new OpenAPIHono(); // Keep OpenAPIHono for potential doc gen later

// GET /users (List)
userRoutes.get(
  '/',
  controller.listUser
);

// POST /users (Create)
userRoutes.post(
  '/',
  validator('json', (value, c) => {
    // Reuse the schema defined in createRoute for validation
    const parsed = createUserRoute.request.body.content['application/json'].schema.safeParse(value);
    if (!parsed.success) {
      return c.json({ error: 'Validation failed', issues: parsed.error.issues }, 400);
    }
    return parsed.data; // Make validated data available via c.req.valid('json')
  }),
  controller.createUser
);


// GET /users/{id}
userRoutes.get(
  '/{id}',
  validator('param', (value, c) => {
    const parsed = getUserByIdRoute.request.params.safeParse(value);
    if (!parsed.success) {
      return c.json({ error: 'Validation failed', issues: parsed.error.issues }, 400);
    }
    return parsed.data;
  }),
  controller.getUserById
);

// PATCH /users/{id}
userRoutes.patch(
  '/{id}',
  validator('param', (value, c) => {
    const parsed = updateUserRoute.request.params.safeParse(value);
    if (!parsed.success) {
      return c.json({ error: 'Validation failed', issues: parsed.error.issues }, 400);
    }
    return parsed.data;
  }),
  validator('json', (value, c) => {
    const parsed = updateUserRoute.request.body.content['application/json'].schema.safeParse(value);
    if (!parsed.success) {
      return c.json({ error: 'Validation failed', issues: parsed.error.issues }, 400);
    }
    return parsed.data;
  }),
  controller.updateUser
);

// DELETE /users/{id}
userRoutes.delete(
  '/{id}',
  validator('param', (value, c) => {
    const parsed = deleteUserRoute.request.params.safeParse(value);
    if (!parsed.success) {
      return c.json({ error: 'Validation failed', issues: parsed.error.issues }, 400);
    }
    return parsed.data;
  }),
  controller.deleteUser
);
 // Conditionally register ID-based routes

// TODO: Optionally re-attach OpenAPI route definitions for documentation generation if needed
// Example: userRoutes.doc('/path', listUserRoute.getOpenAPIMetadata());

export default userRoutes;
"
`;

exports[`generateRoutesFileContent > should generate only non-ID routes if model has no ID field 1`] = `
"import { OpenAPIHono, createRoute, z } from '@hono/zod-openapi';
import { validator } from 'hono/validator';
import { LogEntrySchema, createLogEntrySchema, updateLogEntrySchema } from './schema';
import * as controller from './controller';



// --- Route Definitions ---
// GET /logentrys
const listLogEntryRoute = createRoute({
  method: 'get',
  path: '/',
  tags: ['LogEntry'],
  summary: 'List all logentrys',
  responses: {
    200: {
      description: 'Returns a list of logentrys',
      content: {
        'application/json': {
          schema: z.array(LogEntrySchema),
        },
      },
    },
    // TODO: Define 500 error response
  },
});

// Define ID-based routes only if idField exists
 // End of conditional ID routes

// POST /logentrys - Always defined
const createLogEntryRoute = createRoute({
  method: 'post',
  path: '/',
  tags: ['LogEntry'],
  summary: 'Create a new logentry',
  request: {
    body: {
      content: {
        'application/json': {
          schema: createLogEntrySchema,
        },
      },
    },
  },
  responses: {
    201: {
      description: 'Returns the created logentry',
      content: {
        'application/json': {
          schema: LogEntrySchema,
        },
      },
    },
    400: {
      description: 'Invalid input',
      // TODO: Define standard error schema
    },
    // TODO: Define 500 error response
  },
});




// --- Hono App Setup ---
// Using standard Hono methods for clearer middleware application
const logEntryRoutes = new OpenAPIHono(); // Keep OpenAPIHono for potential doc gen later

// GET /logentrys (List)
logEntryRoutes.get(
  '/',
  controller.listLogEntry
);

// POST /logentrys (Create)
logEntryRoutes.post(
  '/',
  validator('json', (value, c) => {
    // Reuse the schema defined in createRoute for validation
    const parsed = createLogEntryRoute.request.body.content['application/json'].schema.safeParse(value);
    if (!parsed.success) {
      return c.json({ error: 'Validation failed', issues: parsed.error.issues }, 400);
    }
    return parsed.data; // Make validated data available via c.req.valid('json')
  }),
  controller.createLogEntry
);

 // Conditionally register ID-based routes

// TODO: Optionally re-attach OpenAPI route definitions for documentation generation if needed
// Example: logEntryRoutes.doc('/path', listLogEntryRoute.getOpenAPIMetadata());

export default logEntryRoutes;
"
`;
